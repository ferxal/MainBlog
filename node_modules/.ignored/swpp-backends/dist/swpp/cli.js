"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.initCommand = initCommand;
const commander_1 = require("commander");
const fs_1 = __importDefault(require("fs"));
const index_1 = require("../index");
const BasicActions_1 = require("./BasicActions");
const untils_1 = require("./untils");
const HTMLParser = __importStar(require("node-html-parser"));
async function initCommand() {
    commander_1.program.version(index_1.swppVersion, '-v, --version', '查看当前 swpp backends 的版本号');
    commander_1.program.addHelpText('after', '  每行显示一条指令信息，指令后跟方括号表示可选参数，尖括号表示必填参数');
    commander_1.program.option('-b, --build [config: string]', '构建网站的 sw 与版本文件');
    commander_1.program.option('--prod', '设置构建模式为生产模式（默认开发模式）');
    commander_1.program.parse();
    if (commander_1.program.opts().build) {
        const build = commander_1.program.opts().build;
        await runBuild(typeof build === 'string' ? build : undefined, commander_1.program.opts().prod ? 'prod' : 'dev');
    }
    else if (commander_1.program.opts().prod) {
        throw new untils_1.RuntimeException(untils_1.exceptionNames.unsupportedOperate, '--prod 选项必须搭配 --build 使用');
    }
}
/** 检查并初始化 CLI 配置 */
async function checkAndInitConfig(cliConfig) {
    if (!cliConfig.webRoot ||
        !(await fs_1.default.promises.stat(cliConfig.webRoot)).isDirectory()) {
        throw new untils_1.RuntimeException(untils_1.exceptionNames.error, 'CLI 配置文件中缺少 webRoot 配置项或传入了一个非文件夹路径', { webRoot: cliConfig.webRoot });
    }
    if (cliConfig.domJsPath && !cliConfig.domJsPath.endsWith('.js')) {
        throw new untils_1.RuntimeException(untils_1.exceptionNames.invalidValue, 'CLI 配置文件中的 domJsPath 应当传入一个 `/` 开头 `.js` 结尾的字符串');
    }
    if (!cliConfig.configFiles || cliConfig.configFiles.length === 0) {
        throw new untils_1.RuntimeException(untils_1.exceptionNames.nullPoint, 'CLI 配置文件中缺少 configFiles 配置项或数组长度为 0', { configFiles: cliConfig.configFiles });
    }
    if (cliConfig.diffJsonPath && !cliConfig.diffJsonPath.endsWith('.json')) {
        throw new untils_1.RuntimeException(untils_1.exceptionNames.invalidValue, 'CLI 配置文件中的 diffJsonPath 应当传入一个以 `.json` 结尾的字符串');
    }
    const configFiles = typeof cliConfig.configFiles === 'string' ?
        [cliConfig.configFiles] : cliConfig.configFiles;
    configFiles.forEach(path => {
        if (!fs_1.default.existsSync(path)) {
            throw new untils_1.RuntimeException(untils_1.exceptionNames.notFound, 'CLI 配置文件的 configFiles 配置项中某项目录不存在', { path });
        }
    });
    cliConfig.serviceWorker = cliConfig.serviceWorker ?? true;
    cliConfig.auto_register = cliConfig.auto_register ?? true;
    cliConfig.gen_dom = cliConfig.gen_dom ?? true;
}
/** 执行 build 指令 */
async function runBuild(cliJsonPath = './swpp.cli.json', context) {
    if (!cliJsonPath.endsWith('.json')) {
        throw new untils_1.RuntimeException(untils_1.exceptionNames.unsupportedFileType, 'CLI 配置文件仅支持 JSON 格式', { yourPath: cliJsonPath });
    }
    const cliConfig = JSON.parse(await untils_1.utils.readFileUtf8(cliJsonPath));
    await checkAndInitConfig(cliConfig);
    const actions = await BasicActions_1.BasicActions.build({
        context,
        publicPath: cliConfig.webRoot,
        isServiceWorker: cliConfig.serviceWorker ?? true,
        domJsPath: cliConfig.gen_dom ? undefined : cliConfig.domJsPath,
        diffJsonPath: cliConfig.diffJsonPath
    });
    await actions.loadConfigs(Array.isArray(cliConfig.configFiles) ? cliConfig.configFiles : [cliConfig.configFiles]);
    actions.buildConfig();
    await actions.saveFiles();
    if (!cliConfig.auto_register && !cliConfig.gen_dom)
        return;
    const runtime = actions.runtimeData;
    const compilation = actions.compilationData;
    const regexes = cliConfig.excludes?.map?.(it => new RegExp(it)) ?? [];
    const swRegistry = cliConfig.auto_register &&
        `<script>(${runtime.domConfig.read('registry')})()</script>`;
    const domJsScript = cliConfig.gen_dom &&
        `<script defer src="${cliConfig.domJsPath ?? '/sw-dom.js'}"></script>`;
    // 修改 html
    await compilation.compilationEnv.read('PUBLIC_PATH').walkAllFile(async (file) => {
        if (!file.absPath.endsWith('.html') || regexes.some(regex => regex.test(file.basePublic)))
            return;
        const html = await readHtml(compilation, file);
        const head = html.querySelector('head');
        if (swRegistry)
            head.insertAdjacentHTML('afterbegin', swRegistry);
        if (domJsScript)
            head.insertAdjacentHTML('beforeend', domJsScript);
        await untils_1.utils.writeFile(file.absPath, html.outerHTML);
    });
}
async function readHtml(compilation, path) {
    const content = await compilation.compilationEnv.read('readLocalFile')(path);
    return HTMLParser.parse(content);
}
