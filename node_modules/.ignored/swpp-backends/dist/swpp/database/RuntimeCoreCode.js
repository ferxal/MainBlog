"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RuntimeCoreCode = void 0;
const untils_1 = require("../untils");
const RuntimeKeyValueDatabase_1 = require("./RuntimeKeyValueDatabase");
/**
 * 运行时核心功能代码
 */
class RuntimeCoreCode extends RuntimeKeyValueDatabase_1.RuntimeKeyValueDatabase {
    constructor() {
        super('RuntimeCoreCode', buildCommon());
    }
    /** 构建 JS 源代码 */
    buildJsSource() {
        return untils_1.utils.anyToSource(this.entries(), true, 'const');
    }
}
exports.RuntimeCoreCode = RuntimeCoreCode;
function buildCommon() {
    return {
        /** 逃生门功能实现 */
        handleEscape: {
            default: async () => {
                const oldVersion = await readVersion();
                if (ESCAPE && oldVersion && oldVersion.escape !== ESCAPE) {
                    await caches.delete(CACHE_NAME);
                    await postMessage('escape', null);
                }
            }
        },
        /**
         * 缓存增量更新功能实现
         * @param force 是否强制更新
         * @return 标记缓存是否更新，-1 - 新访客，1 - 仅更新版本号，2 - 更新了缓存，string[] - 更新了部分缓存，否则 - 没有进行任何更新
         */
        handleUpdate: {
            default: async (oldVersion, force) => {
                if (!force && oldVersion && Date.now() - oldVersion.tp < UPDATE_CD)
                    return;
                const json = await (await fetch(UPDATE_JSON_URL, {
                    // @ts-ignore
                    priority: 'high'
                })).json();
                const { global, info } = json;
                const newVersion = { global, local: info[0].version, escape: ESCAPE };
                // 新访客或触发了逃生门
                if (!oldVersion || (ESCAPE && ESCAPE !== oldVersion.escape)) {
                    await writeVersion(newVersion);
                    return oldVersion ? 1 : -1;
                }
                // 已是最新版本时跳过剩余步骤
                if (oldVersion.global === global && oldVersion.local === newVersion.local) {
                    await writeVersion(oldVersion);
                    return;
                }
                // 按版本顺序更新缓存，直到找到当前版本
                const expressionList = [];
                for (let infoElement of info) {
                    if (infoElement.version === oldVersion.local) {
                        const urlList = [];
                        const cache = await caches.open(CACHE_NAME);
                        const keys = await cache.keys();
                        for (let request of keys) {
                            const url = request.url;
                            if (url !== VERSION_PATH && expressionList.find(it => it(url))) {
                                await markCacheInvalid(request);
                                urlList.push(url);
                            }
                        }
                        await writeVersion(newVersion);
                        return urlList;
                    }
                    const changeList = infoElement.change;
                    if (changeList) {
                        for (let change of changeList) {
                            expressionList.push(matchUpdateRule(change));
                        }
                    }
                }
                // 运行到这里说明版本号丢失
                await caches.delete(CACHE_NAME);
                await writeVersion(newVersion);
                return 2;
            }
        },
        /** 处理网络请求事件 */
        handleFetchEvent: {
            default: (event) => {
                // @ts-ignore
                let request = event.request;
                if (request.method !== 'GET' || !request.url.startsWith('http'))
                    return;
                if (isBlockRequest(request)) {
                    // @ts-ignore
                    return event.respondWith(new Response(null, { status: 204 }));
                }
                const newRequest = modifyRequest(request);
                if (newRequest)
                    request = newRequest;
                let cleanUrl = request.url;
                for (let i = 0; i < cleanUrl.length; i++) {
                    const item = cleanUrl[i];
                    if (item === '?' || item === '#') {
                        cleanUrl = cleanUrl.substring(0, i);
                    }
                }
                const cacheKey = new URL(normalizeUrl(cleanUrl));
                const cacheRule = matchCacheRule(cacheKey);
                if (cacheRule) {
                    // @ts-ignore
                    event.respondWith(matchFromCaches(cacheKey).then(cacheResponse => {
                        if (cacheResponse && isValidCache(cacheResponse, cacheRule))
                            return cacheResponse;
                        const responsePromise = fetchFile(request)
                            .then(response => {
                            if (isFetchSuccessful(response)) {
                                // noinspection JSIgnoredPromiseFromCall
                                writeResponseToCache(cacheKey, response.clone());
                                return response;
                            }
                            return cacheResponse ?? response;
                        });
                        return cacheResponse ? responsePromise.catch(() => cacheResponse) : responsePromise;
                    }));
                }
                else if (newRequest) {
                    // @ts-ignore
                    event.respondWith(fetchWrapper(request, false, isCors(request)));
                }
            }
        }
    };
}
