"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileUpdateTracker = exports.ResourcesScanner = void 0;
const crypto = __importStar(require("node:crypto"));
const CompilationEnv_1 = require("./database/CompilationEnv");
const JsonBuilder_1 = require("./JsonBuilder");
const untils_1 = require("./untils");
/**
 * 资源文件扫描器
 */
class ResourcesScanner {
    constructor(compilation, oldTracker) {
        this.compilation = compilation;
        this.oldTracker = oldTracker;
    }
    // noinspection JSUnusedGlobalSymbols
    /** 扫描指定目录下的所有文件 */
    async scanLocalFile(path) {
        const matchCacheRule = this.compilation.crossDep.read('matchCacheRule');
        const register = this.compilation.fileParser;
        const jsonInfo = this.compilation.compilationEnv.read('SWPP_JSON_FILE');
        const excludes = [
            path.join(jsonInfo.swppPath, jsonInfo.versionPath),
            path.join(jsonInfo.swppPath, jsonInfo.trackerPath),
            path.join(this.compilation.compilationEnv.read('SERVICE_WORKER') + '.js')
        ];
        if (!this.oldTracker) {
            this.oldTracker = await jsonInfo.fetchTrackerFile(this.compilation);
        }
        const urls = new Set();
        const tracker = new FileUpdateTracker(this.compilation, this.oldTracker);
        await path.walkAllFile(async (file) => {
            if (excludes.includes(file))
                return;
            const localUrl = tracker.normalizeUri(file.basePublic);
            const isCached = !!matchCacheRule.runOnNode(localUrl);
            if (isCached) {
                tracker.addUrl(localUrl.href);
            }
            const set = await register.parserLocalFile(file, content => {
                if (isCached) {
                    const hash = crypto.createHash('md5');
                    hash.update(content);
                    tracker.update(localUrl.pathname, hash.digest('hex'));
                }
            }, isCached);
            set.forEach(it => urls.add(it));
        });
        await this.scanNetworkFile(tracker, urls);
        return tracker;
    }
    /** 扫描网络文件 */
    async scanNetworkFile(tracker, urls, record = new Set()) {
        const matchCacheRule = this.compilation.crossDep.read('matchCacheRule');
        const registry = this.compilation.fileParser;
        const isStable = this.compilation.compilationEnv.read('isStable');
        const appendedUrls = new Set();
        const taskList = new Array(urls.size);
        let i = 0;
        for (let url of urls) {
            const normalizeUri = tracker.normalizeUri(url);
            if (record.has(normalizeUri.href))
                continue;
            record.add(normalizeUri.href);
            const isCached = matchCacheRule.runOnNode(normalizeUri);
            if (isCached) {
                tracker.addUrl(normalizeUri.href);
            }
            if (isStable(normalizeUri)) {
                const oldValue = this.oldTracker?.get?.(normalizeUri.href);
                if (Array.isArray(oldValue)) {
                    const list = tracker.syncStable(normalizeUri, oldValue, this.oldTracker);
                    list.forEach(it => appendedUrls.add(it));
                    continue;
                }
            }
            taskList[i++] = registry.parserUrlFile(normalizeUri.href, !!isCached)
                .then(value => {
                if (isCached) {
                    tracker.update(value.file, value.mark);
                }
                value.urls.forEach(it => appendedUrls.add(it));
            }).catch(err => untils_1.utils.printError('SCAN NETWORK FILE', err));
        }
        await Promise.all(taskList);
        if (appendedUrls.size !== 0)
            await this.scanNetworkFile(tracker, appendedUrls, record);
    }
}
exports.ResourcesScanner = ResourcesScanner;
/**
 * 文件更新监听器
 */
class FileUpdateTracker {
    constructor(compilation, oldTracker) {
        this.compilation = compilation;
        this.oldTracker = oldTracker;
        /** 存储列表，key 为文件路径，value 为文件的唯一标识符 */
        this.map = new Map();
        /** 存储所有存在的 URL */
        this.allUrl = new Set();
    }
    /** 更新一个文件的标识符 */
    update(uri, value) {
        if (typeof value == 'string') {
            if (value.startsWith('[')) {
                throw new untils_1.RuntimeException(untils_1.exceptionNames.invalidValue, `插入数据（"${value}"）时，不应当以方括号开头`);
            }
            this.map.set(uri, value);
        }
        else if (Array.isArray(value)) {
            this.map.set(uri, JSON.stringify(value));
        }
        else {
            this.map.set(uri, JSON.stringify(Array.from(value)));
        }
    }
    /**
     * 同步指定的稳定资源（同步时会连同同步其连接的稳定资源）
     * @return 直接或间接连接的一些需要扫描的资源
     */
    syncStable(uri, value, oldTracker) {
        const isStable = this.compilation.compilationEnv.read('isStable');
        this.update(uri.href, value);
        this.addUrl(uri.href);
        const result = [];
        for (let item of value) {
            this.addUrl(item);
            const itemUrl = new URL(item);
            if (isStable(itemUrl)) {
                const oldValue = oldTracker.get(item);
                if (Array.isArray(oldValue)) {
                    const son = this.syncStable(itemUrl, oldValue, oldTracker);
                    result.push(...son);
                    continue;
                }
            }
            result.push(item);
        }
        return result;
    }
    /** 读取一个文件的标识符 */
    get(uri) {
        const value = this.map.get(this.normalizeUri(uri).href);
        if (!value)
            return;
        return value.startsWith('[') ? JSON.parse(value) : value;
    }
    /** 归一化 uri */
    normalizeUri(uri) {
        if (uri.startsWith('http:'))
            uri = `https:${uri.substring(5)}`;
        const baseUrl = this.compilation.compilationEnv.read('DOMAIN_HOST');
        const url = new URL(uri, baseUrl);
        const normalizer = this.compilation.crossDep.read('normalizeUrl');
        return new URL(decodeURI(normalizer.runOnNode(url.href)));
    }
    /** 添加一个 URL */
    addUrl(url) {
        this.allUrl.add(url);
    }
    // noinspection JSUnusedGlobalSymbols
    /**
     * 判断两个 tracker 的差异
     *
     * 当一个文件满足下列条件任意一条时将会被放入到返回值当中：
     *
     * + 在新旧 tracker 中都存在且唯一标识符发生变化
     * + 在新 tracker 中不存在且在旧 tracker 中存在
     */
    async diff() {
        const baseUrl = this.compilation.compilationEnv.read('DOMAIN_HOST');
        const diff = new JsonBuilder_1.JsonBuilder(this.compilation, this.allUrl);
        const oldTracker = this.oldTracker ??
            await this.compilation.compilationEnv.read('SWPP_JSON_FILE').fetchTrackerFile(this.compilation);
        oldTracker?.map?.forEach?.((value, key) => {
            if (!key.startsWith('/') && untils_1.utils.isSameHost(key, baseUrl)) {
                key = key.substring(baseUrl.href.length - 1);
                if (!key.startsWith('/')) {
                    key = '/' + key;
                }
            }
            const newValue = this.map.get(key);
            if (!newValue || newValue !== value) {
                diff.update(untils_1.utils.splicingUrl(baseUrl, key).href, newValue ?? '');
            }
        });
        return diff;
    }
    // noinspection JSUnusedGlobalSymbols
    /**
     * 将数据序列化为 JSON
     *
     * 具体格式为：
     *
     * ```json
     * {
     *   "version": 4,
     *   "tracker" {
     *     [uri: string]: string
     *   }
     * }
     * ```
     */
    json() {
        const result = {
            version: 4,
            tracker: {}
        };
        this.map.forEach((value, key) => {
            result.tracker[key] = value;
        });
        return JSON.stringify(result);
    }
    /** 解序列化数据 */
    static unJson(compilation, jsonStr) {
        const tracker = new FileUpdateTracker(compilation);
        let json;
        try {
            json = JSON.parse(jsonStr);
        }
        catch (err) {
            throw new untils_1.RuntimeException(untils_1.exceptionNames.invalidValue, 'ResourcesScanner 解序列化失败，传入的字符串是非法的 json。' +
                '请检查您的网站在返回 403、404、429 等错误时是否是使用 HTTP 状态码。' +
                '如果您的网站不实用 HTTP 状态码表示相应错误，请参考 https://swpp.kmar.top/config/cross_dep#isfetchsuccessful 做出相应修改', err);
        }
        switch (json.version) {
            case 4:
                for (let key in json.tracker) {
                    const uri = tracker.normalizeUri(key);
                    tracker.map.set(uri.href, json.tracker[key]);
                }
                break;
            case 3:
                for (let key in json.list) {
                    const value = json.list[key];
                    tracker.map.set(key, value.length === 32 ? value : '');
                }
                break;
            default: throw new untils_1.RuntimeException(untils_1.exceptionNames.unsupportedVersion, `不支持 ${json.version}`);
        }
        return tracker;
    }
    // noinspection JSUnusedGlobalSymbols
    /** 从网络拉取并解析 tracker */
    static async parserJsonFromNetwork(compilation) {
        const domain = compilation.compilationEnv.read('DOMAIN_HOST');
        const jsonInfo = compilation.compilationEnv.read('SWPP_JSON_FILE');
        const url = untils_1.utils.splicingUrl(domain, jsonInfo.swppPath, jsonInfo.trackerPath);
        const fetcher = compilation.compilationEnv.read('NETWORK_FILE_FETCHER');
        const isNotFound = compilation.compilationEnv.read('isNotFound');
        const notFoundLevel = compilation.compilationEnv.read('ALLOW_NOT_FOUND');
        const isFetchSuccessful = compilation.crossDep.read('isFetchSuccessful').runOnNode;
        let error;
        const result = await (async () => {
            try {
                const response = await fetcher.fetch(url);
                if (isNotFound.response(response)) {
                    if (notFoundLevel == CompilationEnv_1.AllowNotFoundEnum.REJECT_ALL) {
                        error = new untils_1.RuntimeException(untils_1.exceptionNames.notFound, `拉取 ${url} 时出现 404 错误`);
                        return;
                    }
                    untils_1.utils.printWarning('SCANNER', '拉取 tracker 时服务器返回了 404，如果是第一次携带 swpp v3 构建网站请忽视这条信息');
                    return new FileUpdateTracker(compilation);
                }
                if (!isFetchSuccessful(response)) {
                    error = new untils_1.RuntimeException(untils_1.exceptionNames.networkError, `拉取 ${url} 时出现网络错误`, { response });
                }
                else {
                    const text = await response.text();
                    return FileUpdateTracker.unJson(compilation, text);
                }
            }
            catch (e) {
                if (notFoundLevel == CompilationEnv_1.AllowNotFoundEnum.ALLOW_ALL && isNotFound.error(e)) {
                    untils_1.utils.printWarning('SCANNER', '拉取 tracker 时 DNS 解析失败，如果是第一次携带 swpp v3 构建网站且网站暂时无法解析请忽视这条信息');
                    return new FileUpdateTracker(compilation);
                }
                error = new untils_1.RuntimeException(untils_1.exceptionNames.error, `拉取或解析历史 Tracker 时出现错误`, e);
            }
            return;
        })();
        if (result)
            return result;
        throw error;
    }
}
exports.FileUpdateTracker = FileUpdateTracker;
