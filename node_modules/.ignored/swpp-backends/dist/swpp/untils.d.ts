import fs, { WriteFileOptions } from 'fs';
import * as crypto from 'node:crypto';
export type ValuesOf<T> = T[keyof T];
export declare const utils: {
    /** 检查指定 URL 是否是合法的 URL */
    checkUrl(url: string): boolean;
    /**
     * 拼接链接
     */
    splicingUrl(base: string | URL, ...values: string[]): URL;
    /**
     * 将任意的对象转化为 JS 源码
     *
     * @param obj 要进行转化的对象
     * @param includeEmptyValue 是否包含空的值，当为 false 时将不在源码中写入值为 null 和 undefined 的内容
     * @param writeAsVar 以变量形式写入时填入值，当存在非法变量名是会报错
     * @return 返回 JS 源代码，注意：该函数不保证导出的代码的美观度，也不保证字符串的引号一定使用某一种引号
     * @throws RuntimeException 若 {@link writeAsVar} 启用且 {@link obj} 中存在非法变量名 / {code = "invalid_var_name"}
     * @throws RuntimeException 若 {@link obj} 中包含 symbol 类型 / {code = "invalid_var_type"}
     *
     * @example <caption>基础示例</caption>
     * // "{hello: 'world'}"
     * anyToSource({hello: 'world', empty: null})
     * @example <caption>includeEmptyValue 示例</caption>
     * // "{hello: 'world', empty: null}"
     * anyToSource({hello: 'world', empty: null}, true)
     * @example <caption>writeAsVar 示例</caption>
     * // """
     * // const hello = 'world';
     * // const code = 'js';
     * // """
     * anyToSource({hello: 'world', code: 'js'}, false, 'const')
     * @example <caption>特殊情况</caption>
     * anyToSource({empty: null})               // "{}"
     * anyToSource({empty: null}, false, 'let') // ""
     * anyToSource(null)                        // ""
     */
    anyToSource(obj: {
        [p: string]: any;
    }, includeEmptyValue?: boolean, writeAsVar?: "let" | "const"): string;
    /** 判断指定链接的 host 是否为指定的 host */
    isSameHost(path: string | URL, baseUrl: URL): boolean;
    /** 计算字符串的哈希值 */
    calcHash(content: crypto.BinaryLike): string;
    time(): string;
    printError(title: string, err: any): void;
    printWarning(title: string, warning: any): void;
    printInfo(title: string, info: any): void;
    /**
     * 将一个对象中的值都映射为另一个类型的值
     * @param obj
     * @param transfer
     */
    objMap<T, R>(obj: Readonly<Record<string, T>>, transfer: (item: T, key: string) => R): {
        [key: string]: R;
    };
    /**
     * 在可迭代容器中查找满足指定条件的元素的下标
     */
    findValueInIterable<T>(set: Iterable<T>, predicate: (item: T) => boolean): {
        index: number;
        value: T;
    }[];
    /**
     * 查找一个字符串中倒数第二次出现的子串的下标
     */
    findSecondLastIndex(str: string, searchString: string, position?: number): number;
    /** 写入一个文件 */
    writeFile(path: fs.PathLike, data: string | NodeJS.ArrayBufferView, optional?: WriteFileOptions): Promise<void>;
    /** 读取一个文件 */
    readFileUtf8(path: fs.PathLike): Promise<string>;
};
export declare const exceptionNames: {
    /** 循环依赖 */
    readonly circularDependencies: "circular_dependencies";
    /** 无效的变量名 */
    readonly invalidVarName: "invalid_var_name";
    /** 无效的变量类型 */
    readonly invalidVarType: "invalid_var_type";
    /** 无效的插入键 */
    readonly invalidKey: "invalid_key";
    /** 无效的插入值 */
    readonly invalidValue: "invalid_value";
    /** KV 库已经被冻结无法修改 */
    readonly isFrozen: "is_frozen";
    /** 不支持的版本号 */
    readonly unsupportedVersion: "unsupported_version";
    /** 不支持的文件类型 */
    readonly unsupportedFileType: "unsupported_file_type";
    /** 不支持的操作 */
    readonly unsupportedOperate: "unsupported_operate";
    /** 空指针 */
    readonly nullPoint: "null_point";
    /** 配置文件已经完成构建 */
    readonly configBuilt: "config_built";
    /** 404 错误 */
    readonly notFound: "not_found";
    /** 文件或目录已存在 */
    readonly fileDuplicate: "file_duplicate";
    /** 超时 */
    readonly timeout: "timeout";
    /** 网络错误 */
    readonly networkError: "network_error";
    /** 未知分类错误 */
    readonly error: "error";
};
/** 运行时异常 */
export declare class RuntimeException extends Error {
    readonly code: ValuesOf<typeof exceptionNames>;
    constructor(code: ValuesOf<typeof exceptionNames>, message: string, causeBy?: any);
}
