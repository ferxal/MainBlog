"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FilePath = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
class FilePath {
    /**
     * @param absPath 绝对路径
     * @param baseProject 相对于项目根目录的路径，如果路径不在项目范围内，则为 null
     * @param basePublic 相对于网站根目录的路径，如果路径不在网站范围内，则为 null
     * @private
     */
    constructor(absPath, baseProject, basePublic) {
        this.absPath = absPath;
        this.baseProject = baseProject;
        this.basePublic = basePublic;
    }
    /**
     * 检查路径是否在网站范围内
     */
    get isPublic() {
        return this.basePublic != null;
    }
    /**
     * 检查路径是否在项目范围内
     */
    get isProject() {
        return this.baseProject != null;
    }
    /**
     * 检查目录或文件是否存在
     */
    exists() {
        return new Promise(resolve => {
            fs_1.default.access(this.absPath, fs_1.default.constants.F_OK, (err) => {
                resolve(!err);
            });
        });
    }
    /**
     * 检查路径是否指向一个目录
     */
    async isDirectory() {
        if (!this.statCache)
            this.statCache = await fs_1.default.promises.stat(this.absPath);
        return this.statCache.isDirectory();
    }
    /**
     * 检查路径是否指向一个文件
     */
    async isFile() {
        if (!this.statCache)
            this.statCache = await fs_1.default.promises.stat(this.absPath);
        return this.statCache.isFile();
    }
    /**
     * 将指定目录拼接到当前路径之后
     */
    append(subPath, ...subPaths) {
        const newAbsPath = path_1.default.posix.join(this.absPath, subPath, ...subPaths);
        let newBaseProject = null;
        let newBasePublic = null;
        if (this.isProject) {
            newBaseProject = path_1.default.posix.join(this.baseProject, subPath, ...subPaths);
            newBaseProject = path_1.default.posix.normalize(newBaseProject);
        }
        if (this.isPublic) {
            newBasePublic = path_1.default.posix.join(this.basePublic, subPath, ...subPaths);
            newBasePublic = path_1.default.posix.normalize(newBasePublic);
        }
        return new FilePath(newAbsPath, newBaseProject, newBasePublic);
    }
    /**
     * 将指定目录拼接到当前路径之后
     */
    join(subPath, ...subPaths) {
        return this.append(subPath, ...subPaths);
    }
    /**
     * 遍历当前路径下的所有文件（不含文件夹）
     * @param consumer
     */
    async walkAllFile(consumer) {
        const queue = [this];
        do {
            const item = queue.pop();
            const dirs = await fs_1.default.promises.readdir(item.absPath);
            for (let subPath of dirs) {
                const path = item.join(subPath);
                if (await path.isDirectory()) {
                    queue.push(path);
                }
                else {
                    await consumer(path);
                }
            }
        } while (queue.length);
    }
    /**
     * 获取文件名
     */
    fileName() {
        return path_1.default.posix.basename(this.absPath);
    }
    /**
     * 获取上一级目录
     */
    parent() {
        let newBaseProject = this.baseProject ? path_1.default.posix.dirname(this.baseProject) : null;
        let newBasePublic = this.basePublic ? path_1.default.posix.dirname(this.basePublic) : null;
        if (newBaseProject === '.')
            newBaseProject = '';
        if (newBasePublic === '.')
            newBasePublic = '';
        return new FilePath(path_1.default.posix.dirname(this.absPath), newBaseProject, newBasePublic);
    }
    /** 获取拓展名，包含 `.` */
    extname() {
        return path_1.default.posix.extname(this.absPath);
    }
    /**
     * 创建目录（不包含当前目录，只创建父级目录）
     */
    async mkdirs() {
        const parent = this.parent();
        if (!await parent.exists()) {
            await fs_1.default.promises.mkdir(parent.absPath, { recursive: true });
        }
    }
    /**
     * 从绝对路径获取 FilePath
     * @param absPath 绝对路径
     * @param compilation 编译期数据
     */
    static fromAbsPath(absPath, compilation) {
        absPath = path_1.default.posix.normalize(absPath);
        const projectRoot = compilation.compilationEnv.read('PROJECT_PATH');
        const publicRoot = compilation.compilationEnv.read('PUBLIC_PATH');
        if (projectRoot.absPath.startsWith(absPath)) {
            return projectRoot.join(absPath.substring(projectRoot.absPath.length));
        }
        else if (publicRoot.absPath.startsWith(absPath)) {
            return publicRoot.join(absPath.substring(publicRoot.absPath.length));
        }
        else {
            return new FilePath(absPath, null, null);
        }
    }
    /**
     * 构建网站根目录的 FilePath
     * @param path 绝对路径或相对路径（相对于项目根目录），以 `/` 开头或 `x:/` 开头判定为绝对路径
     * @param projectRoot 项目根目录（绝对路径或相对路径（相对于工作目录））
     */
    static buildPublicRoot(path, projectRoot) {
        if (!(path.startsWith('/') || path_1.default.isAbsolute(path))) {
            path = path_1.default.resolve(path);
        }
        const absPath = path_1.default.posix.normalize(path);
        let baseProject = absPath.startsWith(projectRoot.absPath)
            ? absPath.substring(projectRoot.absPath.length) : null;
        if (baseProject && (baseProject.startsWith('/') || baseProject.startsWith('\\'))) {
            baseProject = baseProject.substring(1);
        }
        if (baseProject) {
            baseProject = path_1.default.posix.normalize(baseProject);
        }
        return new FilePath(absPath, baseProject, '');
    }
    /**
     * 构建项目根目录的 FilePath
     * @param path 绝对路径或相对路径（相对于工作目录）
     */
    static buildProjectRoot(path) {
        if (!(path.startsWith('/') || path_1.default.isAbsolute(path))) {
            path = path_1.default.resolve(path);
        }
        path = path_1.default.posix.normalize(path);
        return new FilePath(path, '', null);
    }
}
exports.FilePath = FilePath;
/** 空目录 */
FilePath.EMPTY = new FilePath('', null, null);
