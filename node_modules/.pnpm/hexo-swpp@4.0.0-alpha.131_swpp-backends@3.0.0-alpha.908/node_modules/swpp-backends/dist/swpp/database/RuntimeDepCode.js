"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RuntimeDepCode = void 0;
const ConfigCluster_1 = require("../config/ConfigCluster");
const untils_1 = require("../untils");
const RuntimeKeyValueDatabase_1 = require("./RuntimeKeyValueDatabase");
/** 运行时依赖代码 */
class RuntimeDepCode extends RuntimeKeyValueDatabase_1.RuntimeKeyValueDatabase {
    constructor() {
        super('RuntimeDepCode', buildCommon());
    }
    /** 构建 JS 源代码 */
    buildJsSource() {
        return untils_1.utils.anyToSource(this.entries(), true, 'const');
    }
}
exports.RuntimeDepCode = RuntimeDepCode;
const fetchFastestAndStandbyRequests = (requestOrUrl, optional) => {
    // @ts-ignore
    const request = requestOrUrl.url ? requestOrUrl : new Request(requestOrUrl);
    const standbyList = getStandbyRequests(request);
    if (standbyList)
        return fetchStandby(request, standbyList, optional);
    const fastestList = getFastestRequests(request);
    if (fastestList)
        return fetchFastest(fastestList, optional);
    return fetchWrapper(request, true, isCors(request), optional).catch(transferError2Response);
};
const fetchFastestRequests = (requestOrUrl, optional) => {
    // @ts-ignore
    const request = requestOrUrl.url ? requestOrUrl : new Request(requestOrUrl);
    const fastestList = getFastestRequests(request);
    if (fastestList)
        return fetchFastest(fastestList, optional);
    return fetchWrapper(request, true, isCors(request), optional).catch(transferError2Response);
};
const fetchStandbyRequests = (requestOrUrl, optional) => {
    // @ts-ignore
    const request = requestOrUrl.url ? requestOrUrl : new Request(requestOrUrl);
    const standbyList = getStandbyRequests(request);
    if (standbyList)
        return fetchStandby(request, standbyList, optional);
    return fetchWrapper(request, true, isCors(request), optional).catch(transferError2Response);
};
function buildCommon() {
    return {
        /** 尝试匹配一个 cache */
        matchFromCaches: {
            default: (request) => caches.match(request, { cacheName: CACHE_NAME })
        },
        /**
         * 将一个 response 写入到 cache 中
         * @param request 请求信息
         * @param response 要写入的 response，注意需要自己克隆 response
         * @param date 是否写入时间戳
         */
        writeResponseToCache: {
            default: async (request, response, date) => {
                if (date) {
                    const headers = new Headers(response.headers);
                    headers.set(STORAGE_TIMESTAMP, new Date().toISOString());
                    response = new Response(response.body, {
                        status: response.status,
                        headers
                    });
                }
                const cache = await caches.open(CACHE_NAME);
                await cache.put(request, response);
            }
        },
        /** 标记一个缓存为废弃缓存 */
        markCacheInvalid: {
            default: (request) => matchFromCaches(request).then(response => {
                if (!response)
                    return;
                const headers = new Headers(response.headers);
                headers.set(INVALID_KEY, '1');
                return writeResponseToCache(request, new Response(response.body, { status: response.status, headers }));
            })
        },
        /** 判断指定的缓存是否是有效缓存 */
        isValidCache: {
            default: (response, rule) => {
                const headers = response.headers;
                if (headers.has(INVALID_KEY))
                    return false;
                if (rule === INFINITE_CACHE)
                    return true;
                const storage = headers.get(STORAGE_TIMESTAMP);
                if (!storage)
                    return true;
                const storageDate = new Date(storage).getTime();
                const nowTimestamp = Date.now();
                // @ts-ignore
                return nowTimestamp - storageDate < rule;
            }
        },
        /** 读取版本号 */
        readVersion: {
            default: () => matchFromCaches(VERSION_PATH)
                .then(response => response?.json?.())
        },
        /** 写入版本号 */
        writeVersion: {
            default: (version) => {
                version.tp = Date.now();
                return writeResponseToCache(VERSION_PATH, new Response(JSON.stringify(version)));
            }
        },
        /**
         * 向指定客户端发送消息
         * @param type 消息类型
         * @param data 消息体
         * @param goals 客户端对象，留空表示所有客户端
         */
        postMessage: {
            default: (async (type, data, ...goals) => {
                if (!goals.length) {
                    // @ts-ignore
                    goals = await clients.matchAll();
                }
                const body = { type, data };
                for (let client of goals) {
                    client.postMessage(body);
                }
            })
        },
        /** 将 error 转换为一个 599 Response */
        transferError2Response: {
            default: (err) => new Response(JSON.stringify({
                type: err.name,
                message: err.message,
                stack: err.stack,
                addition: err
            }), {
                status: 599,
                headers: {
                    'Content-Type': 'application/json'
                }
            })
        },
        /** 拉取一个文件 */
        fetchWrapper: {
            default: (request, banCache, cors, optional) => {
                const init = {
                    referrerPolicy: request.referrerPolicy ?? '',
                    ...optional
                };
                init.cache = banCache ? 'no-store' : 'default';
                if (cors) {
                    init.mode = 'cors';
                    init.credentials = 'same-origin';
                }
                return fetch(request, init);
            }
        },
        /** 是否启用 cors */
        isCors: {
            default: (() => false)
        },
        /** 获取竞速列表 */
        getFastestRequests: {
            default: null,
            checker(value) {
                if (value != null && typeof value != 'function') {
                    return {
                        value, message: '传入的对象应当为 function 或 null'
                    };
                }
                return false;
            }
        },
        /** 获取备用 URL 列表 */
        getStandbyRequests: {
            default: null,
            checker(value) {
                if (value != null && typeof value != 'function') {
                    return {
                        value, message: '传入的对象应当为 function 或 null'
                    };
                }
                return false;
            }
        },
        /** URL 竞速拉取 */
        fetchFastest: {
            default: async (list, optional) => {
                const fallbackFetch = (request, controller) => {
                    return fetchWrapper(request, true, true, {
                        ...optional,
                        signal: controller?.signal
                    });
                };
                const controllers = Array.from({ length: list.length }, () => new AbortController());
                try {
                    const { i: index, r: response } = await Promise.any(list.map((it, index) => fallbackFetch(it, controllers[index])
                        .then(response => isFetchSuccessful(response) ? { i: index, r: response } : Promise.reject(response))));
                    for (let k = 0; k < list.length; k++) {
                        if (k != index)
                            controllers[k].abort();
                    }
                    return response;
                }
                catch (err) {
                    const value = err.errors[0];
                    return value.body ? value : transferError2Response(err);
                }
            }
        },
        /** 备用 URL */
        fetchStandby: {
            default: async (request, standbyRequests, optional) => {
                const fallbackFetch = (request, controller) => {
                    return fetchWrapper(request, true, true, {
                        ...optional,
                        signal: controller?.signal
                    });
                };
                // 需要用到的一些字段，未初始化的后面会进行初始化
                let id, standbyResolve, standbyReject;
                // 尝试封装 response
                const resolveResponse = (index, response) => isFetchSuccessful(response) ? { i: index, r: response } : Promise.reject(response);
                const { t: time, r: src, l: listGetter } = standbyRequests;
                const controllers = new Array(listGetter.length + 1);
                // 尝试同时拉取 standbyRequests 中的所有 Request
                const task = () => Promise.any(listGetter().map((it, index) => fallbackFetch(it, controllers[index + 1] = new AbortController())
                    .then(response => resolveResponse(index + 1, response)))).then(obj => standbyResolve(obj))
                    .catch(() => standbyReject());
                // 尝试拉取初始 request
                const firstFetch = fallbackFetch(src || request, controllers[0] = new AbortController())
                    .then(response => resolveResponse(0, response))
                    .catch(err => {
                    // 如果失败则跳过等待
                    clearTimeout(id);
                    // noinspection JSIgnoredPromiseFromCall
                    task();
                    return Promise.reject(err); // 保留当前错误
                });
                // 延时拉取其它 request
                const standby = new Promise((resolve1, reject1) => {
                    standbyResolve = resolve1;
                    standbyReject = reject1;
                    id = setTimeout(task, time);
                });
                try {
                    const { i: index, r: response } = await Promise.any([firstFetch, standby]);
                    // 中断未完成的请求
                    for (let k = 0; controllers[k]; k++) {
                        if (k != index)
                            controllers[k].abort();
                    }
                    return response;
                }
                catch (err) {
                    const value = err.errors[0];
                    return value.body ? value : transferError2Response(err);
                }
            }
        },
        /**
         * 拉取文件。
         *
         * 该方法不得抛出任何形式的异常，当遇到异常时，应当封装为 response 返回，状态码设置为 `6xx`
         *
         * @param {RequestInfo | URL} request 请求头或 URL
         * @param {?RequestInit} optional 配置项
         * @return {Response}
         */
        fetchFile: {
            default: (0, ConfigCluster_1.defineLazyInitConfig)((runtime) => {
                const runtimeDep = runtime.runtimeDep;
                const hasFastestRequests = runtimeDep.hasValue('getFastestRequests');
                const hasStandbyRequests = runtimeDep.hasValue('getStandbyRequests');
                if (hasFastestRequests && hasStandbyRequests) {
                    return fetchFastestAndStandbyRequests;
                }
                else if (hasFastestRequests) {
                    return fetchFastestRequests;
                }
                else if (hasStandbyRequests) {
                    return fetchStandbyRequests;
                }
                else {
                    return (request, optional) => {
                        // @ts-ignore
                        if (!request.url)
                            request = new Request(request);
                        return fetchWrapper(request, true, true, optional).catch(transferError2Response);
                    };
                }
            })
        },
        /** 是否阻断请求 */
        isBlockRequest: {
            default: (() => false)
        },
        /** 修改请求 */
        modifyRequest: {
            default: (() => null)
        }
    };
}
