import * as crypto from 'node:crypto';
import { FilePath } from '../FilePath';
import { CompilationData } from '../SwCompiler';
import { KeyValueDatabase } from './KeyValueDatabase';
export type COMMON_TYPE_COMP_FP = ReturnType<typeof buildCommon>;
export declare class CompilationFileParser extends KeyValueDatabase<FileParser<crypto.BinaryLike>, COMMON_TYPE_COMP_FP> {
    constructor();
    /** 解析本地文件 */
    parserLocalFile(path: FilePath, cb?: (content: crypto.BinaryLike) => void, force?: boolean): Promise<Set<string>>;
    /** 解析网络文件 */
    parserNetworkFile(response: Response, callback?: (content: crypto.BinaryLike) => Promise<void> | void): Promise<Set<string>>;
    /**
     * 解析指定的 URL
     * @param url 链接
     * @param isCached 该链接指向的资源是否需要缓存
     */
    parserUrlFile(url: string, isCached: boolean): Promise<FileMark>;
    /**
     * 解析指定类型的文件内容
     * @param type 文件类型
     * @param content 文件内容
     * @param path 文件路径
     */
    parserContent(type: string, content: string, path: FilePath | URL): Promise<Set<string>>;
}
declare function buildCommon($this: any): {
    readonly html: {
        readonly default: {
            readonly readFromLocal: (compilation: CompilationData, path: FilePath) => Promise<string>;
            readonly readFromNetwork: (_: CompilationData, response: Response) => Promise<string>;
            readonly extractUrls: (compilation: CompilationData, content: string, filePath: FilePath | URL) => Promise<Set<string>>;
        };
    };
    readonly css: {
        readonly default: {
            readonly readFromLocal: (compilation: CompilationData, path: FilePath) => Promise<string>;
            readonly readFromNetwork: (_: CompilationData, response: Response) => Promise<string>;
            readonly extractUrls: (compilation: CompilationData, content: string, filePath: FilePath | URL) => Promise<Set<string>>;
        };
    };
};
/**
 * 文件处理器
 *
 * 用于处理指定类型的文件，从中提取文件的 mark 和外部链接列表
 */
export interface FileParser<T extends crypto.BinaryLike> {
    /**
     * 从本地读取一个文件
     * @param compilation 编译期依赖
     * @param path 文件路径
     */
    readFromLocal(compilation: CompilationData, path: FilePath): Promise<T>;
    /**
     * 从网络读取一个文件
     * @param compilation 编译期依赖
     * @param response 拉取的结果
     */
    readFromNetwork(compilation: CompilationData, response: Response): Promise<T>;
    /**
     * 从文件内容中提取 URL
     * @param compilation 编译期依赖
     * @param content 文件内容
     * @param fileUrl 文件的 URL
     */
    extractUrls(compilation: CompilationData, content: T, fileUrl: FilePath | URL): Promise<Set<string>>;
    /**
     * 计算一个链接对应的资源的标识符及其内部资源
     * @return 返回 undefined/null 表示使用缺省逻辑
     */
    calcUrl?(url: string): Promise<Omit<FileMark, 'file'> | undefined | null>;
}
/**
 * 存储文件标识信息
 */
export interface FileMark {
    /** URL */
    file: string;
    /**
     * 文件标识符或子文件列表
     *
     * 如果链接为稳定链接，则为子文件列表，否则为文件标识符
     */
    mark: string | Set<string>;
    /** URL 列表 */
    urls: Set<string>;
}
export {};
