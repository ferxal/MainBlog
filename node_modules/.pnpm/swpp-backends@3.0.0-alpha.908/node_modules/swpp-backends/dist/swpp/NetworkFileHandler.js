"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FiniteConcurrencyFetcher = void 0;
const http = __importStar(require("node:http"));
const https = __importStar(require("node:https"));
const path_1 = __importDefault(require("path"));
const untils_1 = require("./untils");
/** 支持并发控制的网络文件拉取工具 */
class FiniteConcurrencyFetcher {
    constructor() {
        this.fetchingCount = 0;
        this.waitList = [];
        this.limit = 100;
        this.timeout = 5000;
        this.referer = 'https://swpp.example.com';
        this.userAgent = 'swpp-backends';
        this.headers = {};
        /** 最大重试次数 */
        this.retryLimit = 3;
        /** 重试次数计数 */
        this.retryCount = 0;
    }
    async fetch(request) {
        const fetchBase = async () => {
            const list = this.getStandbyList(request);
            if (!list || list.length === 0) {
                throw new untils_1.RuntimeException(untils_1.exceptionNames.invalidValue, `#getStandByList(${request.toString()}) 返回了空值或空的数组`);
            }
            if (list.length === 1)
                return this.fetchHelper(list[0], 0);
            try {
                return await this.fetchHelper(list[0], 0);
            }
            catch (err) {
                list.shift();
                try {
                    return await Promise.any(list.map(it => this.fetchHelper(it, 0)));
                }
                catch {
                    throw err;
                }
            }
        };
        try {
            return await fetchBase();
        }
        catch (err) {
            return new Response(JSON.stringify({
                type: err.name,
                message: err.message,
                stack: err.stack,
                addition: err
            }), {
                status: 599,
                headers: {
                    'Content-Type': 'application/json'
                }
            });
        }
    }
    fetchHelper(url, _count) {
        if (this.fetchingCount < this.limit) {
            return this.createFetchTask(url, _count);
        }
        else {
            return new Promise((resolve, reject) => {
                this.waitList.push({ url, resolve, reject });
            });
        }
    }
    async createFetchTask(url, _count = 0) {
        ++this.fetchingCount;
        try {
            const response = await this.request(url.toString(), () => {
                if (this.retryCount > 10) { // 超时请求数量过多时自动降低并发量
                    this.retryCount = 5;
                    this.limit = Math.round(this.limit * 2 / 3);
                    untils_1.utils.printWarning('FETCHER', `超时请求数量过多，已将阈值自动降低为 ${this.limit}`);
                }
            });
            --this.fetchingCount;
            return response;
        }
        catch (e) {
            --this.fetchingCount;
            // 出现异常时判断是否需要重试
            if (this.isRetry(url, _count, e)) {
                ++this.retryCount;
                untils_1.utils.printWarning('FETCHER', `自动重试请求：${url}，重试次数：${_count + 1}，重试原因：“${e}”`);
                return this.fetchHelper(url, _count + 1);
            }
            // 如果不需要重试直接向上级抛出异常
            throw e;
        }
        finally { // 请求结束后触发等待队列中的任务
            if (this.waitList.length !== 0 && this.fetchingCount < this.limit) {
                const item = this.waitList.pop();
                this.createFetchTask(item.url)
                    .then(response => item.resolve(response))
                    .catch(err => item.reject(err));
            }
        }
    }
    getUrlContentType(url, response) {
        let contentType;
        if (url.endsWith('/')) {
            contentType = 'html';
        }
        else {
            contentType = path_1.default.extname(url).substring(1);
        }
        if (!contentType) {
            if (response)
                contentType = response.headers.get('content-type') ?? '';
            if (contentType.startsWith('text/'))
                contentType = contentType.substring(5);
            if (contentType === 'javascript')
                contentType = 'js';
        }
        return contentType;
    }
    isRetry(_request, count, err) {
        return count < this.retryLimit && err instanceof untils_1.RuntimeException && err.code === untils_1.exceptionNames.timeout;
    }
    getStandbyList(url) {
        return [url];
    }
    request(url, onTimeout) {
        if (!/^(https?):\/\/([^!@#$%^&*?.\s-]([^!@#$%^&*?.\s]{0,63}[^!@#$%^&*?.\s])?\.)+[a-z]{2,6}\/?/.test(url)) {
            throw new untils_1.RuntimeException(untils_1.exceptionNames.invalidValue, '传入了一个非法的 URL', { url });
        }
        const startTime = Date.now();
        const responsePromise = new Promise(async (resolve, reject) => {
            let id = undefined;
            const isHttps = url.startsWith('https:');
            const client = isHttps ? https : http;
            const req = client.get(url, {
                headers: {
                    ...this.headers,
                    referer: this.referer,
                    "user-agent": this.userAgent
                },
                // @ts-ignore
                agent: this['proxy']
            }, response => {
                if ([301, 302, 307, 308].includes(response.statusCode ?? 0)) {
                    const location = response.headers.location;
                    if (!location) {
                        reject(new Error(`GET ${url} Error: 返回了 ${response.statusCode} 但没有包含 Location 字段`));
                    }
                    else if (location.startsWith('/')) {
                        const rightIndex = url.indexOf('/', 8);
                        const host = rightIndex < 0 ? url : url.substring(0, rightIndex);
                        this.request(host + location, onTimeout)
                            .then(response => resolve(response))
                            .catch(err => reject(err));
                    }
                    else if (/^https?:\/\//.test(location)) {
                        this.request(location, onTimeout)
                            .then(response => resolve(response))
                            .catch(err => reject(err));
                    }
                    else {
                        const lastIndex = url.lastIndexOf('/');
                        let locationUrl;
                        if (lastIndex < 8) {
                            locationUrl = url + '/' + location;
                        }
                        else {
                            locationUrl = url.substring(0, lastIndex + 1) + location;
                        }
                        this.request(new URL(locationUrl).href, onTimeout)
                            .then(response => resolve(response))
                            .catch(err => reject(err));
                    }
                }
                else {
                    const bufferArray = [];
                    response.on('data', (chunk) => {
                        bufferArray.push(chunk);
                    });
                    response.on('end', () => {
                        clearTimeout(id);
                        const buffer = Buffer.concat(bufferArray);
                        resolve(new Response(buffer, {
                            status: response.statusCode,
                            headers: response.headers
                        }));
                    });
                }
            });
            req.on('error', err => reject(err));
            if (this.timeout > 0) {
                id = setTimeout(() => {
                    onTimeout?.();
                    req.destroy(new untils_1.RuntimeException(untils_1.exceptionNames.timeout, `GET ${url} Timeout`));
                }, this.timeout);
            }
        });
        responsePromise.finally(() => {
            untils_1.utils.printInfo('FETCHER', `GET ${url}: ${(Date.now() - startTime) / 1000}s`);
        });
        return responsePromise;
    }
}
exports.FiniteConcurrencyFetcher = FiniteConcurrencyFetcher;
