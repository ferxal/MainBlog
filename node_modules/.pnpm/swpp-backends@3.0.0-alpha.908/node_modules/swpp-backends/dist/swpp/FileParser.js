"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileParserRegistry = void 0;
exports.buildFileParser = buildFileParser;
const path_1 = __importDefault(require("path"));
const untils_1 = require("./untils");
class FileParserRegistry {
    constructor(compilation, oldTracker) {
        this.compilation = compilation;
        this.oldTracker = oldTracker;
        this.map = new Map();
    }
    /** 注册一种处理器 */
    registry(type, parser) {
        this.map.set(type, parser);
    }
    /** 判断是否支持指定类型 */
    containsType(type) {
        return this.map.has(type);
    }
    /** 解析本地文件 */
    async parserLocalFile(path, cb, force) {
        const parser = this.map.get(path_1.default.extname(path).substring(1));
        if (!parser) {
            if (force && cb) {
                const reader = this.compilation.compilationEnv.read('readLocalFile');
                const content = await reader(path);
                cb(content);
            }
            return new Set();
        }
        const content = await parser.readFromLocal(this.compilation, path);
        cb?.(content);
        return await parser.extractUrls(this.compilation, content);
    }
    /** 解析网络文件 */
    async parserNetworkFile(response, callback) {
        const fileHandler = this.compilation.compilationEnv.read('NETWORK_FILE_FETCHER');
        const contentType = fileHandler.getUrlContentType(response.url, response);
        const parser = this.map.get(contentType);
        if (!parser) {
            if (callback) {
                const blob = await response.blob();
                const array = await blob.stream().getReader().read();
                callback(array.value);
            }
            return new Set();
        }
        const content = await parser.readFromNetwork(this.compilation, response);
        if (callback)
            await callback(content);
        return await parser.extractUrls(this.compilation, content);
    }
    /**
     * 解析指定的 URL
     * @param url 链接
     * @param isCached 该链接指向的资源是否需要缓存
     */
    async parserUrlFile(url, isCached) {
        const fileHandler = this.compilation.compilationEnv.read('NETWORK_FILE_FETCHER');
        const contentType = fileHandler.getUrlContentType(url);
        if (!contentType && !isCached)
            return { file: url, mark: '', urls: new Set() };
        const parser = this.map.get(contentType);
        if (!parser && !isCached)
            return { file: url, mark: '', urls: new Set() };
        if (parser?.calcUrl) {
            const result = await parser.calcUrl(url);
            if (result)
                return {
                    file: url,
                    ...result
                };
        }
        const fetcher = this.compilation.compilationEnv.read('NETWORK_FILE_FETCHER');
        const urls = new Set();
        let mark = '';
        await fetcher.fetch(url)
            .then(response => this.parserNetworkFile(response, isCached ? content => {
            mark = untils_1.utils.calcHash(content);
        } : undefined))
            .then(urls => urls.forEach(it => urls.add(it)));
        return { file: url, mark, urls };
    }
    /** 解析指定类型的文件内容 */
    async parserContent(type, content) {
        const parser = this.map.get(type);
        if (!parser)
            return new Set();
        return await parser.extractUrls(this.compilation, content);
    }
}
exports.FileParserRegistry = FileParserRegistry;
function buildFileParser(parser) {
    return parser;
}
