"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonBuilder = void 0;
const untils_1 = require("./untils");
/**
 * JSON 构建器，用于构建在前端使用的版本更新文件。
 */
class JsonBuilder {
    /**
     * @param compilation 编译期属性
     * @param urls 网站中所有可能被缓存的 URL
     * @param map 新旧文件差异的 map，key 为 URL，value 为新的 md5 值
     */
    constructor(compilation, urls, map = new Map()) {
        this.compilation = compilation;
        this.urls = urls;
        this.map = map;
    }
    update(key, value) {
        this.map.set(key, value);
    }
    /** 将 Builder 序列化为 JSON */
    serialize() {
        const diff = {};
        this.map.forEach((value, key) => diff[key] = value);
        return JSON.stringify(diff);
    }
    /**
     * 构建在前端使用的版本信息文件
     */
    // noinspection JSUnusedGlobalSymbols
    async buildJson() {
        const json = await this.compilation.compilationEnv.read('SWPP_JSON_FILE').fetchVersionFile(this.compilation);
        if (json.info.length == 0) {
            json.info.push({ version: 1 });
            return json;
        }
        const newChange = createUpdateChangeExps(this.urls, this.map.keys());
        json.info.unshift({
            version: json.info[0].version + 1,
            change: [newChange]
        });
        this.zipJson(json);
        this.limitJson(json);
        return json;
    }
    zipJson(json) {
        const matchUpdateRule = this.compilation.crossDep.read('matchUpdateRule');
        const htmlMatcher = matchUpdateRule.runOnNode({ flag: 'html' });
        // 打散新版本的所有规则
        json.info[0].change = json.info[0].change?.flatMap(exp => {
            if (!Array.isArray(exp.value))
                return [exp];
            return exp.value.map(it => ({
                flag: exp.flag, value: it
            }));
        });
        // 压缩第一个版本的内容
        const indexes = (() => {
            const change = json.info[0]?.change;
            if (!change)
                return new Set();
            let htmlCount = 0;
            const indexes = new Set();
            // 统计每个表达式匹配的资源及刷新的 HTML 总量
            const indexesArray = change.map(exp => {
                const matcher = matchUpdateRule.runOnNode(exp);
                const result = new Set();
                untils_1.utils.findValueInIterable(this.urls, it => !!matcher(it))
                    .forEach(item => {
                    indexes.add(item.index);
                    result.add(item.index);
                    if (htmlMatcher(item.value))
                        ++htmlCount;
                });
                return result;
            });
            // 如果 HTML 更新数量超过阈值，则直接清除所有 HTML 的缓存
            if (htmlCount > 0) {
                const htmlLimit = this.compilation.compilationEnv.read('JSON_HTML_LIMIT');
                if (htmlLimit > 0 && htmlCount > htmlLimit) {
                    change.unshift({ flag: 'html' });
                    const indexes = new Set();
                    untils_1.utils.findValueInIterable(this.urls, it => !!htmlMatcher(it))
                        .forEach(({ index }) => indexes.add(index));
                    indexesArray.unshift(indexes);
                }
            }
            // 分析哪些表达式是冗余的
            const invalidIndex = new Array(indexesArray.length);
            for (let i = 0; i < indexesArray.length; i++) {
                if (invalidIndex[i])
                    continue;
                const parent = indexesArray[i];
                o: for (let k = 0; k < indexesArray.length; k++) {
                    if (i == k || invalidIndex[k])
                        continue;
                    for (let item of indexesArray[k]) {
                        if (!parent.has(item)) {
                            continue o;
                        }
                    }
                    invalidIndex[k] = true;
                }
            }
            // 生成新的表达式
            const validExp = new Map();
            for (let i = 0; i < invalidIndex.length; i++) {
                if (invalidIndex[i])
                    continue;
                const oldExpList = validExp.get(change[i].flag);
                const expList = oldExpList ?? [];
                if (change[i].value) {
                    console.assert(typeof change[i].value == 'string', `change[${i}].value = ${change[i].value} 应当为字符串`);
                    expList.push(change[i].value);
                }
                if (!oldExpList)
                    validExp.set(change[i].flag, expList);
            }
            const newChange = json.info[0].change = [];
            validExp.forEach((value, flag) => {
                switch (value.length) {
                    case 0:
                        newChange.push({ flag });
                        break;
                    case 1:
                        newChange.push({ flag, value: value[0] });
                        break;
                    default:
                        newChange.push({ flag, value });
                }
            });
            return indexes;
        })();
        // 移除后续表达式中冗余的内容
        if (indexes.size == 0)
            return;
        for (let i = 1; i < json.info.length; i++) {
            const changes = json.info[i].change;
            if (!changes)
                continue;
            for (let k = changes.length - 1; k >= 0; k--) {
                const change = changes[k];
                const values = change.value ? (Array.isArray(change.value) ? change.value : [change.value]) : [];
                const tmpChange = {
                    flag: change.flag,
                    value: ''
                };
                for (let j = values.length - 1; j >= 0; j--) {
                    tmpChange.value = values[j];
                    const matcher = matchUpdateRule.runOnNode(tmpChange);
                    const matchIndex = untils_1.utils.findValueInIterable(this.urls, url => !!matcher(url));
                    if (matchIndex.every(it => indexes.has(it.index))) {
                        values.splice(j, 1);
                    }
                }
                if (values.length == 0)
                    changes.splice(k, 1);
                else if (values.length == 1)
                    change.value = values[0];
                else
                    change.value = values;
            }
            if (changes.length === 0) {
                delete json.info[i]['change'];
            }
        }
    }
    limitJson(json) {
        const lengthLimit = this.compilation.compilationEnv.read('VERSION_LENGTH_LIMIT');
        if (lengthLimit == 0)
            return;
        let sum = 0;
        for (let i = 0; i < json.info.length; i++) {
            sum += JSON.stringify(json.info[i]).length;
            if (sum > lengthLimit) {
                if (i == 0)
                    json.info = [{ version: json.info[0].version }];
                else
                    json.info.splice(i);
                return;
            }
        }
    }
}
exports.JsonBuilder = JsonBuilder;
/**
 * 构建更新表达式
 *
 * 具体实现为使用字典树构建最优后缀匹配表达式，时间复杂度 O(N + M)
 */
function createUpdateChangeExps(urls, refresh) {
    function newNode() {
        return {
            next: new Array(128),
            flag: false,
            isEnd: false
        };
    }
    const head = newNode();
    const insert = (content, flag) => {
        let cur = head;
        for (let i = content.length - 1; i >= 0; i--) {
            const index = content.charCodeAt(i);
            if (cur.next[index]) {
                cur = cur.next[index];
            }
            else {
                cur = cur.next[index] = newNode();
            }
        }
        cur.flag = flag;
        cur.isEnd = true;
    };
    urls.forEach(it => insert(it, false));
    for (let item of refresh) {
        insert(item, true);
    }
    function dfs(node) {
        if (node.isEnd)
            return;
        node.flag = true;
        for (let next of node.next) {
            if (next) {
                dfs(next);
                node.flag = node.flag && next.flag;
            }
        }
    }
    dfs(head);
    let dfs2S = [];
    const result = [];
    function dfs2(node) {
        if (node.flag) {
            result.push(dfs2S.reduceRight((a, b) => a + b, ''));
            return;
        }
        for (let i = 0; i < node.next.length; i++) {
            const next = node.next[i];
            if (next) {
                dfs2S.push(String.fromCharCode(i));
                dfs2(next);
                dfs2S.pop();
            }
        }
    }
    dfs2(head);
    return { flag: 'suf', value: result };
}
