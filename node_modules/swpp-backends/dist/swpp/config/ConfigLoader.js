"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigLoader = void 0;
exports.defineConfig = defineConfig;
exports.defineCompilationEnv = defineCompilationEnv;
exports.defineCompilationFP = defineCompilationFP;
exports.defineCrossEnv = defineCrossEnv;
exports.defineRuntimeDep = defineRuntimeDep;
exports.defineCrossDep = defineCrossDep;
exports.defineRuntimeCore = defineRuntimeCore;
exports.defineDomConfig = defineDomConfig;
exports.defineRuntimeEvent = defineRuntimeEvent;
exports.defineModifier = defineModifier;
const jiti_1 = require("jiti");
const path_1 = __importDefault(require("path"));
const SwCompiler_1 = require("../SwCompiler");
const untils_1 = require("../untils");
const SpecialConfig_1 = require("./SpecialConfig");
/** 正在加载配置的 loader */
let activeConfigLoader = null;
const TMP_PW = Math.random().toString();
class ConfigLoader {
    constructor(context = 'dev') {
        this.context = context;
        this.modifierList = [];
        Object.defineProperty(this, '9zLoadFromInside', {
            value: (config, pw) => {
                if (pw !== TMP_PW)
                    throw new untils_1.RuntimeException(untils_1.exceptionNames.error, '该函数仅能由内部调用');
                for (let configKey in config) {
                    const key = configKey;
                    const item = config[key];
                    config[key] = untils_1.utils.objMap(item, it => SpecialConfig_1.SpecialConfig.isContextConfig(it) ? it[this.context] : it);
                }
                if ('modifier' in config) {
                    this.modifierList.push(config.modifier);
                }
                if (this.config)
                    ConfigLoader.mergeConfig(this.config, config);
                else
                    this.config = config;
            },
            writable: false,
            enumerable: false
        });
    }
    // noinspection JSUnusedGlobalSymbols
    /**
     * 加载一个配置文件，越早加载的优先级越高
     * @param file 配置文件的绝对路径
     */
    async load(file) {
        file = path_1.default.normalize(file);
        const extensionName = path_1.default.extname(file).substring(1);
        if (!ConfigLoader.extensions.includes(extensionName)) {
            throw new untils_1.RuntimeException(untils_1.exceptionNames.unsupportedFileType, `配置文件传入了不支持的文件类型：${extensionName}，仅支持：${ConfigLoader.extensions}`, { configPath: file });
        }
        await ConfigLoader.waitLoad();
        let error = true;
        activeConfigLoader?.onRelease?.();
        activeConfigLoader = new ConfigLoaderLock(this, () => {
            if (error)
                throw new untils_1.RuntimeException(untils_1.exceptionNames.error, '锁竞争时出现异常');
        }, file);
        const task = ConfigLoader.prevTask = ConfigLoader.jiti.import(file).then(() => error = false);
        await task;
    }
    /**
     * 加载一个在代码层面编写的配置
     */
    // noinspection JSUnusedGlobalSymbols
    async loadFromCode(config) {
        await ConfigLoader.waitLoad();
        // @ts-ignore
        this['9zLoadFromInside'](config, TMP_PW);
    }
    static async waitLoad() {
        let prev;
        do {
            prev = ConfigLoader.prevTask;
            await prev;
        } while (prev !== ConfigLoader.prevTask);
    }
    // noinspection JSUnusedGlobalSymbols
    /** 将配置项的内容写入到环境中 */
    generate() {
        if (!this.config)
            throw new untils_1.RuntimeException(untils_1.exceptionNames.nullPoint, '构建配之前必须至少加载一个配置文件');
        // 构建属性集
        const { runtime, compilation } = (this.modifierList.find(it => it.build)?.build ?? (() => {
            const compilation = new SwCompiler_1.CompilationData();
            const runtime = new SwCompiler_1.RuntimeData(compilation);
            return { runtime, compilation };
        }))();
        runtime.initCompilation(compilation);
        compilation.initRuntime(runtime);
        const config = this.config;
        /** 将指定配置项目写入到 KV 库中 */
        const writeConfigToKv = (key, value, database) => {
            if (SpecialConfig_1.SpecialConfig.isNoCacheConfig(value)) {
                database.update(key, value);
            }
            else {
                if (typeof value === 'object') {
                    const def = database.readDefault(key);
                    ConfigLoader.mergeConfig(value, def, false);
                }
                database.update(key, value ?? null);
            }
        };
        // 写入运行时信息
        const writeRuntime = () => {
            for (let configKey in config) {
                if (!/^(runtime|dom)[A-Z_]/.test(configKey))
                    continue;
                const configValue = config[configKey];
                const database = runtime.getDatabase(configKey);
                for (let key in configValue) {
                    writeConfigToKv(key, configValue[key], database);
                }
            }
        };
        // 写入编译期信息
        const writeCompilation = () => {
            if (!config.compilationEnv)
                throw new untils_1.RuntimeException(untils_1.exceptionNames.nullPoint, '配置项必须包含 compilationEnv 选项！');
            for (let configKey in config) {
                if (!/^compilation[A-Z_]/.test(configKey))
                    continue;
                if (!(configKey in compilation)) {
                    throw new untils_1.RuntimeException(untils_1.exceptionNames.nullPoint, `配置项中传入了一个不存在的分类[${configKey}]`);
                }
                const env = config[configKey];
                for (let key in env) {
                    writeConfigToKv(key, env[key], compilation[configKey]);
                }
            }
        };
        // 写入 cross
        const writeCross = () => {
            for (let configKey in config) {
                if (!/^cross[A-Z_]/.test(configKey))
                    continue;
                const env = config[configKey];
                const database = runtime.getDatabase(configKey);
                for (let key in env) {
                    writeConfigToKv(key, env[key], database);
                }
            }
        };
        // 运行 registry
        for (let i = this.modifierList.length - 1; i >= 0; i--) {
            const modifier = this.modifierList[i];
            modifier.registry?.(runtime, compilation);
        }
        writeRuntime();
        writeCompilation();
        writeCross();
        // 运行 dynamicUpdate
        for (let i = this.modifierList.length - 1; i >= 0; i--) {
            const modifier = this.modifierList[i];
            modifier.dynamicUpdate?.(runtime, compilation);
        }
        // 冻结 KV 库
        runtime.freezeAll();
        compilation.freezeAll();
        Object.freeze(runtime.insertOrder);
        Object.freeze(runtime);
        Object.freeze(compilation);
        return Object.freeze({ runtime, compilation });
    }
    /** 将新配置合并到已有配置中 */
    static mergeConfig(config, other, isTop = true) {
        function mergeHelper(high, low, skip) {
            function loop(key) {
                if (key.startsWith('_') || (skip && key == 'modifier'))
                    return;
                const lowValue = low[key];
                if (key in high) {
                    const highValue = high[key];
                    if (highValue === undefined) {
                        high[key] = lowValue;
                        return;
                    }
                    if (typeof highValue != typeof lowValue)
                        return;
                    if (typeof highValue == 'object' && !SpecialConfig_1.SpecialConfig.isIndivisibleConfig(highValue)) {
                        mergeHelper(highValue, lowValue, false);
                    }
                }
                else {
                    high[key] = lowValue;
                }
            }
            for (let key in low) {
                loop(key);
            }
            if (other.constructor.name !== 'Object') {
                const list = Object.getOwnPropertyNames(Object.getPrototypeOf(low));
                for (let key of list) {
                    if (!ConfigLoader.mergeBlackList.includes(key))
                        loop(key);
                }
            }
        }
        mergeHelper(config, other, isTop);
    }
}
exports.ConfigLoader = ConfigLoader;
/** 支持的拓展名列表 */
ConfigLoader.extensions = [
    'js', 'ts', 'cjs', 'cts', 'mjs', 'mjs'
];
ConfigLoader.jiti = (0, jiti_1.createJiti)(__filename, {
    fsCache: false,
    alias: {
        'swpp-backends/dist': path_1.default.join(__dirname, '..', '..'),
        'swpp-backends': path_1.default.join(__dirname, '..', '..')
    }
});
ConfigLoader.prevTask = null;
ConfigLoader.mergeBlackList = ['constructor', 'hasOwnProperty', 'isPropertyOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf'];
class ConfigLoaderLock {
    constructor(loader, onRelease, file) {
        this.loader = loader;
        this.onRelease = onRelease;
        this.file = file;
    }
    check(file) {
        if (file !== this.file)
            throw new untils_1.RuntimeException(untils_1.exceptionNames.error, `错误地在 ${this.file} 加载时期载入了 ${file} 中的配置`);
    }
}
function invokeLoader(loader, config) {
    const stack = new Error().stack.split('\n');
    const dist = stack[3];
    let filePath;
    if (dist.endsWith(')')) {
        const startIndex = dist.lastIndexOf('(');
        const endIndex = untils_1.utils.findSecondLastIndex(dist, ':');
        filePath = dist.substring(startIndex + 1, endIndex);
    }
    else {
        const startIndex = dist.indexOf('at ');
        const endIndex = untils_1.utils.findSecondLastIndex(dist, ':');
        filePath = dist.substring(startIndex + 3, endIndex);
    }
    activeConfigLoader.check(path_1.default.normalize(filePath));
    // @ts-ignore
    loader['9zLoadFromInside'](config, TMP_PW);
}
/** 定义一个通过 `export default` 导出的配置 */
function defineConfig(config) {
    invokeLoader(activeConfigLoader.loader, config);
}
/** 定义一个通过 `export const compilationEnv` 导出的配置 */
function defineCompilationEnv(config) {
    invokeLoader(activeConfigLoader.loader, { compilationEnv: config });
}
/** 定义一个通过 `export const compilationFileParser` 导出的配置 */
function defineCompilationFP(config) {
    invokeLoader(activeConfigLoader.loader, { compilationFileParser: config });
}
/** 定义一个通过 `export const crossEnv` 导出的配置 */
function defineCrossEnv(config) {
    invokeLoader(activeConfigLoader.loader, { crossEnv: config });
}
/** 定义一个通过 `export const runtimeDep` 导出的配置 */
function defineRuntimeDep(config) {
    invokeLoader(activeConfigLoader.loader, { runtimeDep: config });
}
/** 定义一个通过 `export const crossDep` 导出的配置 */
function defineCrossDep(config) {
    invokeLoader(activeConfigLoader.loader, { crossDep: config });
}
/** 定义一个通过 `export const runtimeCore` 导出的配置 */
function defineRuntimeCore(config) {
    invokeLoader(activeConfigLoader.loader, { runtimeCore: config });
}
/** 定义一个通过 `export const domConfig` 导出的配置 */
function defineDomConfig(config) {
    invokeLoader(activeConfigLoader.loader, { domConfig: config });
}
/** 定义一个通过 `export const runtimeEvent` 导出的配置 */
function defineRuntimeEvent(config) {
    invokeLoader(activeConfigLoader.loader, { runtimeEvent: config });
}
/** 定义一个通过 `export const modifier` 导出的配置 */
function defineModifier(config) {
    invokeLoader(activeConfigLoader.loader, { modifier: config });
}
