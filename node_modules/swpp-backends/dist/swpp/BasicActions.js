"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BasicActions = void 0;
const ConfigCluster_1 = require("./config/ConfigCluster");
const ConfigLoader_1 = require("./config/ConfigLoader");
const FilePath_1 = require("./FilePath");
const ResourcesScanner_1 = require("./ResourcesScanner");
const SwCompiler_1 = require("./SwCompiler");
const untils_1 = require("./untils");
class BasicActions {
    /**
     * 构建一个基础的 swpp 行为封装器
     */
    static async build(optional) {
        const actions = new BasicActions(optional.context, optional.isServiceWorker, optional.domJsPath, optional.diffJsonPath, optional.trackLink !== true);
        await actions.configLoader.loadFromCode({
            compilationEnv: {
                PUBLIC_PATH: (0, ConfigCluster_1.defineLazyInitConfig)((_, compilation) => {
                    return FilePath_1.FilePath.buildPublicRoot(optional.publicPath, compilation.compilationEnv.read('PROJECT_PATH'));
                })
            }
        });
        return actions;
    }
    constructor(context, isBuildServiceWorker, domJsPath, diffJsonPath, disableTrack) {
        this.context = context;
        this.isBuildServiceWorker = isBuildServiceWorker;
        this.domJsPath = domJsPath;
        this.diffJsonPath = diffJsonPath;
        this.disableTrack = disableTrack;
        this.configLoader = new ConfigLoader_1.ConfigLoader(this.context);
        /**
         * 各个文件的生成路径，为空则表示不生成（或配置未初始化）
         */
        this.paths = {
            trackerJson: null,
            versionJson: null,
            serviceWorker: null,
            domJs: null,
            diffJson: null
        };
        this.buildCaches = {};
        if (disableTrack) {
            untils_1.utils.printInfo('Track', '链接追踪（静态分析）已被关闭，缓存主动更新已自动禁用，请勿使用永久缓存');
        }
        else {
            untils_1.utils.printInfo('Track', '链接追踪（静态分析）已开启，如果发现行为异常请及时反馈');
        }
    }
    /**
     * 加载一个配置文件或配置
     * @param pathOrCode 配置文件的绝对路径或配置对象
     */
    loadConfig(pathOrCode) {
        if (!this.configLoader) {
            throw new untils_1.RuntimeException(untils_1.exceptionNames.configBuilt, '配置文件加载阶段已经结束');
        }
        if (typeof pathOrCode === 'string') {
            return this.configLoader.load(pathOrCode);
        }
        else {
            return this.configLoader.loadFromCode(pathOrCode);
        }
    }
    /**
     * 批量加载配置项
     * @param pathOrCodes
     */
    async loadConfigs(pathOrCodes) {
        for (let pathOrCode of pathOrCodes) {
            await this.loadConfig(pathOrCode);
        }
    }
    /**
     * 生成配置对象
     */
    buildConfig() {
        if (!this.configLoader) {
            throw new untils_1.RuntimeException(untils_1.exceptionNames.configBuilt, '配置文件加载阶段已经结束');
        }
        const { runtime, compilation } = this.configLoader.generate();
        this.runtimeData = runtime;
        this.compilationData = compilation;
        this.configLoader = undefined;
        if (this.disableTrack) {
            const matcher = runtime.crossDep.read('matchCacheRule');
            const checker = (text) => {
                if (!text.includes('INFINITE_CACHE'))
                    return true;
                const list = text.replaceAll('\r', '').split('\n');
                let inStr = '';
                let inComment = false;
                o: for (let string of list) {
                    for (let i = 0; i < string.length; i++) {
                        if (inStr) {
                            if (string[i] == inStr)
                                inStr = '';
                        }
                        else if (inComment) {
                            if (string[i] == '*' && string[i + 1] === '/') {
                                inComment = false;
                                ++i;
                            }
                        }
                        else {
                            switch (string[i]) {
                                case '"':
                                case '`':
                                case `"`:
                                    inStr = string[i];
                                    continue;
                                case '/':
                                    if (string[i + 1] === '*') {
                                        inComment = true;
                                    }
                                    else if (string[i + 1] === '/') {
                                        continue o;
                                    }
                                    break;
                                default:
                                    if (string.startsWith('INFINITE_CACHE', i)) {
                                        return false;
                                    }
                                    break;
                            }
                        }
                    }
                }
                return true;
            };
            if (!checker(matcher.runOnBrowser.toString())) {
                throw new untils_1.RuntimeException(untils_1.exceptionNames.unsupportedOperate, '禁用引用链分析时禁止在 matchCacheRule 返回 INFINITE_CACHE。' +
                    '如果您没有返回该值，可能是由于存在与该字段同名的变量或其它内容，从而导致 SWPP 误判，请您修改与 INFINITE_CACHE 重复的名称。');
            }
        }
        const compilationEnv = compilation.compilationEnv;
        const publicRoot = compilationEnv.read('PUBLIC_PATH');
        const jsonInfo = compilationEnv.read('SWPP_JSON_FILE');
        this.paths.trackerJson = publicRoot.join(jsonInfo.swppPath, jsonInfo.trackerPath);
        this.paths.versionJson = publicRoot.join(jsonInfo.swppPath, jsonInfo.versionPath);
        if (this.isBuildServiceWorker) {
            const swPath = compilationEnv.read('SERVICE_WORKER');
            this.paths.serviceWorker = publicRoot.join(swPath + '.js');
        }
        if (this.domJsPath) {
            this.paths.domJs = publicRoot.join(this.domJsPath);
        }
        if (this.diffJsonPath) {
            this.paths.diffJson = publicRoot.join(this.diffJsonPath);
        }
    }
    /**
     * 构建 swpp 的各项 json、js 文件
     *
     * 该函数的结果内部会进行缓存，多次调用没有性能损耗
     *
     * @param excludeFilter 需排除的文件
     */
    async buildFiles(excludeFilter = []) {
        if (!this.compilationData || !this.runtimeData) {
            throw new untils_1.RuntimeException(untils_1.exceptionNames.configBuilt, '配置文件加载阶段还未结束');
        }
        const globalCacheKey = 'global:' + excludeFilter.join(',');
        if (globalCacheKey in this.buildCaches)
            return (await this.buildCaches[globalCacheKey]);
        const cachePromise = {
            resolve: null,
            reject: null
        };
        this.buildCaches[globalCacheKey] = new Promise((resolve, reject) => {
            cachePromise.resolve = resolve;
            cachePromise.reject = reject;
        });
        try {
            const publicRoot = this.compilationData.compilationEnv.read('PUBLIC_PATH');
            const scanner = new ResourcesScanner_1.ResourcesScanner(this.compilationData);
            let newTracker = 'newTracker' in this.buildCaches ?
                (await this.buildCaches['newTracker']) : null;
            let updateJsonBuilder = 'jsonBuilder' in this.buildCaches ?
                (await this.buildCaches['jsonBuilder']) : null;
            const readValueCache = async (key) => {
                return await this.buildCaches[`value:${key}`];
            };
            const result = [
                (!excludeFilter.includes('tracker') && {
                    key: 'tracker',
                    path: this.paths.trackerJson,
                    content: await readValueCache('tracker') || (newTracker || (newTracker = await (this.buildCaches['newTracker'] = scanner.scanLocalFile(publicRoot)))).json()
                }), (newTracker && !excludeFilter.includes('version') && {
                    key: 'version',
                    path: this.paths.versionJson,
                    content: await readValueCache('version') || JSON.stringify(await (updateJsonBuilder || (updateJsonBuilder = await (this.buildCaches['jsonBuilder'] = newTracker.diff()))).buildJson())
                }), (this.paths.serviceWorker && !excludeFilter.includes('serviceWorker') && {
                    key: 'serviceWorker',
                    path: this.paths.serviceWorker,
                    content: await readValueCache('serviceWorker') || new SwCompiler_1.SwCompiler().buildSwCode(this.runtimeData)
                }), (this.paths.domJs && !excludeFilter.includes('domJs') && {
                    key: 'domJs',
                    path: this.paths.domJs,
                    content: await readValueCache('domJs') || this.runtimeData.domConfig.buildJsSource()
                }), (updateJsonBuilder && this.paths.diffJson && !excludeFilter.includes('diffJson') && {
                    key: 'diffJson',
                    path: this.paths.diffJson,
                    content: await readValueCache('diffJson') || updateJsonBuilder.serialize()
                })
            ].filter(it => it);
            for (let item of result) {
                this.buildCaches[`value:${item.key}`] = Promise.resolve(item.content);
            }
            cachePromise.resolve(result);
            return result;
        }
        catch (e) {
            cachePromise.reject(e);
            throw e;
        }
    }
    /**
     * 生成 swpp 的各项 json、js 文件并写入到硬盘
     * @param excludeFilter 需排除的文件
     */
    async saveFiles(excludeFilter = []) {
        if (this.disableTrack) {
            if (!excludeFilter.includes('tracker')) {
                excludeFilter.push('tracker');
            }
            if (!excludeFilter.includes('version')) {
                excludeFilter.push('version');
            }
            if (!excludeFilter.includes('diffJson')) {
                excludeFilter.push('diffJson');
            }
        }
        const fileList = await this.buildFiles(excludeFilter);
        for (let item of fileList) {
            if (await item.path.exists()) {
                throw new untils_1.RuntimeException(untils_1.exceptionNames.fileDuplicate, `指定文件[${item.path.absPath}]已存在`);
            }
        }
        await Promise.all(fileList.map(it => {
            it.path.mkdirs().then(() => untils_1.utils.writeFile(it.path.absPath, it.content));
        }));
    }
}
exports.BasicActions = BasicActions;
