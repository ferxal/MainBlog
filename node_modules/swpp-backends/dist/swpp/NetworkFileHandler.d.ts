import * as http from 'node:http';
/**
 * 网络文件拉取工具
 *
 * 其中任何方法不得抛出异常
 */
export interface NetworkFileHandler {
    /** 最大并发量 */
    limit: number;
    /** 超时时间（毫秒） */
    timeout: number;
    /** 拉取文件时使用的 referer */
    referer: string;
    /** 拉取文件时使用的 ua */
    userAgent: string;
    /** HTTP 代理 */
    proxy?: http.Agent;
    /** 需要额外写入的 header（不包含 ua 和 referer） */
    headers: {
        [name: string]: string;
    };
    /** 拉取文件 */
    fetch(request: RequestInfo | URL): Promise<Response>;
    /** 获取指定文件的类型 */
    getUrlContentType(url: string, response?: Response): string;
    /**
     * 判断请求失败后是否重试
     * @param request 请求内容
     * @param count 已重试次数（不包括本次）
     * @param err 失败的原因
     */
    isRetry(request: RequestInfo | URL, count: number, err: any): boolean;
    /**
     * 获取备用 URL 列表
     * @param url
     * @return 返回的数组中的第一个元素将用于替换原有的 URL
     */
    getStandbyList(url: string | URL): (string | URL)[];
}
/** 支持并发控制的网络文件拉取工具 */
export declare class FiniteConcurrencyFetcher implements NetworkFileHandler {
    private fetchingCount;
    private waitList;
    limit: number;
    timeout: number;
    referer: string;
    userAgent: string;
    headers: {};
    /** 最大重试次数 */
    retryLimit: number;
    /** 重试次数计数 */
    private retryCount;
    fetch(request: string | URL): Promise<Response>;
    private fetchHelper;
    private createFetchTask;
    getUrlContentType(url: string, response?: Response): string;
    isRetry(_request: RequestInfo | URL, count: number, err: any): boolean;
    getStandbyList(url: string | URL): (string | URL)[];
    private request;
}
