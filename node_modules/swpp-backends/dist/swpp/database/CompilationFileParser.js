"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.CompilationFileParser = void 0;
const HTMLParser = __importStar(require("node-html-parser"));
const untils_1 = require("../untils");
const KeyValueDatabase_1 = require("./KeyValueDatabase");
class CompilationFileParser extends KeyValueDatabase_1.KeyValueDatabase {
    constructor() {
        super('CompilationFileParser');
        this.lazyInit(buildCommon(this));
    }
    /** 解析本地文件 */
    async parserLocalFile(path, cb, force) {
        const extname = path.extname().substring(1);
        if (this.hasKey(extname)) {
            const parser = this.read(extname);
            const content = await parser.readFromLocal(this.compilation, path);
            cb?.(content);
            return await parser.extractUrls(this.compilation, content, path.parent());
        }
        else {
            if (force && cb) {
                const reader = this.compilation.compilationEnv.read('readLocalFile');
                const content = await reader(path);
                cb(content);
            }
            return new Set();
        }
    }
    /** 解析网络文件 */
    async parserNetworkFile(response, callback) {
        const url = response.url;
        const fileHandler = this.compilation.compilationEnv.read('NETWORK_FILE_FETCHER');
        const contentType = fileHandler.getUrlContentType(url, response);
        if (this.hasKey(contentType)) {
            const parser = this.read(contentType);
            const content = await parser.readFromNetwork(this.compilation, response);
            if (callback)
                await callback(content);
            return await parser.extractUrls(this.compilation, content, new URL(url));
        }
        else {
            if (callback) {
                const buffer = await response.arrayBuffer();
                const array = new Uint8Array(buffer);
                callback(array);
            }
            return new Set();
        }
    }
    /**
     * 解析指定的 URL
     * @param url 链接
     * @param isCached 该链接指向的资源是否需要缓存
     */
    async parserUrlFile(url, isCached) {
        const fileHandler = this.compilation.compilationEnv.read('NETWORK_FILE_FETCHER');
        const contentType = fileHandler.getUrlContentType(url);
        if (!contentType && !isCached)
            return { file: url, mark: '', urls: new Set() };
        const parser = this.hasKey(contentType) ? this.read(contentType) : undefined;
        if (!parser && !isCached)
            return { file: url, mark: '', urls: new Set() };
        if (parser?.calcUrl) {
            const result = await parser.calcUrl(url);
            if (result)
                return {
                    file: url,
                    ...result
                };
        }
        const fetcher = this.compilation.compilationEnv.read('NETWORK_FILE_FETCHER');
        const urls = new Set();
        let mark = '';
        await fetcher.fetch(url)
            .then(response => this.parserNetworkFile(response, isCached ? content => {
            mark = untils_1.utils.calcHash(content);
        } : undefined))
            .then(urls => urls.forEach(it => urls.add(it)))
            .catch(err => new Response(JSON.stringify({
            type: err.type,
            message: err.message,
            stack: err.stack,
            addition: err
        }), {
            status: 599,
            headers: {
                'Content-Type': 'application/json'
            }
        }));
        return { file: url, mark, urls };
    }
    /**
     * 解析指定类型的文件内容
     * @param type 文件类型
     * @param content 文件内容
     * @param path 文件路径
     */
    async parserContent(type, content, path) {
        if (!this.hasKey(type))
            return new Set();
        const parser = this.read(type);
        return await parser.extractUrls(this.compilation, content, path);
    }
}
exports.CompilationFileParser = CompilationFileParser;
function buildCommon($this) {
    const registry = $this;
    return {
        html: {
            default: {
                readFromLocal(compilation, path) {
                    return compilation.compilationEnv.read('readLocalFile')(path);
                },
                readFromNetwork(_, response) {
                    return response.text();
                },
                async extractUrls(compilation, content, filePath) {
                    const baseUrl = compilation.compilationEnv.read("DOMAIN_HOST");
                    const html = HTMLParser.parse(content, {
                        blockTextElements: {
                            script: true, style: true
                        }
                    });
                    const queue = [html];
                    const result = new Set();
                    async function handleItem(item) {
                        queue.push(...((item.childNodes ?? []).filter(it => it instanceof HTMLParser.HTMLElement)));
                        if (!item.tagName)
                            return;
                        switch (item.tagName.toLowerCase()) {
                            case 'script': {
                                const src = item.attributes.src;
                                if (src) {
                                    if (!untils_1.utils.isSameHost(src, baseUrl)) {
                                        result.add(src);
                                    }
                                }
                                else {
                                    const son = await registry.parserContent('js', item.rawText, filePath);
                                    son.forEach(it => result.add(it));
                                }
                                break;
                            }
                            case 'link': {
                                if (item.attributes.rel !== 'preconnect') {
                                    const href = item.attributes.href;
                                    if (!href) {
                                        const son = await registry.parserContent('css', item.rawText, filePath);
                                        son.forEach(it => result.add(it));
                                    }
                                    else if (!untils_1.utils.isSameHost(href, baseUrl)) {
                                        result.add(href);
                                    }
                                }
                                break;
                            }
                            case 'img':
                            case 'source':
                            case 'iframe':
                            case 'embed': {
                                const src = item.attributes.src;
                                if (src && !untils_1.utils.isSameHost(src, baseUrl)) {
                                    result.add(src);
                                }
                                break;
                            }
                            case 'object': {
                                const data = item.attributes.data;
                                if (data && !untils_1.utils.isSameHost(data, baseUrl)) {
                                    result.add(data);
                                }
                                break;
                            }
                            case 'style': {
                                const son = await registry.parserContent('css', item.rawText, filePath);
                                son.forEach(it => result.add(it));
                                break;
                            }
                        }
                    }
                    try {
                        do {
                            const item = queue.pop();
                            await handleItem(item);
                        } while (queue.length > 0);
                    }
                    catch (e) {
                        throw new untils_1.RuntimeException(untils_1.exceptionNames.error, '解析 HTML 时出现错误', e);
                    }
                    return result;
                }
            }
        },
        css: {
            default: {
                readFromLocal(compilation, path) {
                    return compilation.compilationEnv.read('readLocalFile')(path);
                },
                readFromNetwork(_, response) {
                    return response.text();
                },
                async extractUrls(compilation, content, filePath) {
                    const baseUrl = compilation.compilationEnv.read('DOMAIN_HOST');
                    let splitRoot = '';
                    if (filePath instanceof URL) {
                        splitRoot = filePath.href;
                    }
                    else if (filePath.isPublic) {
                        splitRoot = untils_1.utils.splicingUrl(baseUrl, filePath.basePublic).href;
                    }
                    if (!splitRoot)
                        splitRoot = baseUrl.href;
                    const urls = new Set();
                    /** 从指定位置开始查询注释 */
                    const findComment = (tag, start) => {
                        for (let i = start; i < content.length;) {
                            const item = content[i];
                            switch (item) {
                                case tag[0]:
                                    if (content[i + 1] === tag[1])
                                        return i;
                                    ++i;
                                    break;
                                case '"':
                                case '\'':
                                    while (true) {
                                        const index = content.indexOf(item, i + 1);
                                        if (index < 0)
                                            return -1;
                                        i = index + 1;
                                        if (content[index - 1] !== '\\')
                                            break;
                                    }
                                    break;
                                default:
                                    ++i;
                                    break;
                            }
                        }
                        return -1;
                    };
                    for (let i = 0; i < content.length;) {
                        const left = findComment('/*', i);
                        let sub;
                        if (left === -1) {
                            sub = content.substring(i);
                            i = Number.MAX_VALUE;
                        }
                        else {
                            sub = content.substring(i, left);
                            const right = findComment('*/', left + 2);
                            if (right === -1)
                                i = Number.MAX_VALUE;
                            else
                                i = right + 2;
                        }
                        // 通过正则表达式匹配 url(xxx) / @import 'xxx' 格式的内容
                        sub.match(/(url\(.*?\))|(@import\s+['"].*?['"])|((https?:)?\/\/[^\s/$.?#].\S*)/g)
                            // 将字符串两侧的内容删除，留下 URL 部分
                            ?.map(it => it.replace(/(^url\(\s*(['"]?))|((['"]?\s*)\)$)|(^@import\s+['"])|(['"]$)/g, ''))
                            // 如果是一个相对路径，则将其拼接到当前文件的后面
                            ?.map(it => /^https?:\/\//.test(it) ? it : untils_1.utils.splicingUrl(splitRoot, it))
                            // 过滤掉当前网站的文件
                            ?.filter(it => !untils_1.utils.isSameHost(it, baseUrl))
                            // 将内容添加到结果集
                            ?.forEach(it => urls.add(it.toString()));
                    }
                    return urls;
                }
            }
        }
    };
}
