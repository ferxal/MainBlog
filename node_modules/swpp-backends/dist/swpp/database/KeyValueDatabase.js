"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyValueDatabase = void 0;
exports.buildEnv = buildEnv;
exports.readThisValue = readThisValue;
const SpecialConfig_1 = require("../config/SpecialConfig");
const untils_1 = require("../untils");
/** 键值对存储器 */
class KeyValueDatabase {
    /**
     * @param namespace 命名空间
     * @param map 默认值
     * @param globalChecker 全局检查器（优先于每个属性设置的 checker 执行），遇到问题直接抛出异常
     */
    constructor(namespace, map, globalChecker) {
        this.namespace = namespace;
        this.globalChecker = globalChecker;
        this.dataValues = {};
        this.valueCaches = {};
        this._runtime = null;
        this._compilation = null;
        if (map) {
            Object.assign(this.dataValues, map);
        }
    }
    /** 延迟初始化 */
    lazyInit(map) {
        Object.assign(this.dataValues, map);
    }
    /** 初始化各项数据 */
    initRuntimeAndCompilation(runtime, compilation) {
        this.runtime = runtime;
        this.compilation = compilation;
    }
    /**
     * 读取指定键对应的值。
     *
     * 注意：允许被缓存的值返回后是不允许被修改的，不缓存的值是允许修改的。
     */
    read(_key) {
        const key = _key;
        if (key in this.valueCaches) {
            return this.valueCaches[key];
        }
        const item = this.dataValues[key];
        if (!item)
            throw new untils_1.RuntimeException(untils_1.exceptionNames.invalidKey, `输入的 key[${key}] 不存在`);
        if (SpecialConfig_1.SpecialConfig.isRuntimeSpecialConfig(item.default)) {
            item.default = item.default.get(this.runtime, this.compilation);
        }
        // 获取真实值
        let value = item.manual ?? item.default;
        let isNoCache = false;
        if (SpecialConfig_1.SpecialConfig.isRuntimeSpecialConfig(value)) {
            this.runtime.debugCallChain.push(this.namespace, key);
            value = value.get(this.runtime, this.compilation);
            this.runtime.debugCallChain.pop(this.namespace, key);
            if (SpecialConfig_1.SpecialConfig.isNoCacheConfig(value)) {
                isNoCache = true;
            }
        }
        // 进行类型预检
        if (!(item.default === null || item.default === undefined || value === null || value === undefined) && typeof value != typeof item.default) {
            throw new untils_1.RuntimeException(untils_1.exceptionNames.invalidValue, '用户传入的值类型与缺省值类型不统一', { key, default: item.default, value });
        }
        // 执行全局检查
        this.globalChecker?.(key, value);
        // 执行用户数据检查
        const checkResult = item.checker?.(value);
        if (checkResult) {
            throw new untils_1.RuntimeException(untils_1.exceptionNames.invalidValue, `设置的值非法`, { key, ...checkResult });
        }
        // 如果不需要缓存直接返回，否则存入缓存后返回
        if (isNoCache)
            return value;
        return this.valueCaches[key] = value;
    }
    /** 读取默认配置 */
    readDefault(_key) {
        const key = _key;
        const item = this.dataValues[key];
        if (!item)
            throw new untils_1.RuntimeException(untils_1.exceptionNames.invalidKey, `传入的 key[${key}] 不存在`);
        return SpecialConfig_1.SpecialConfig.isRuntimeSpecialConfig(item) ? item.get(this.runtime, this.compilation) : item.default;
    }
    /**
     * 设置指定键对应的值
     */
    update(key, manual) {
        if (!(key in this.dataValues))
            throw new untils_1.RuntimeException(untils_1.exceptionNames.invalidKey, `传入的 key[${key}] 不存在`);
        this.dataValues[key].manual = manual;
        delete this.valueCaches[key];
    }
    /**
     * 追加键值对
     */
    append(key, env) {
        if (key in this.dataValues)
            throw new untils_1.RuntimeException(untils_1.exceptionNames.invalidKey, `追加的 key[${key}] 已存在`);
        if ('manual' in env)
            throw new untils_1.RuntimeException(untils_1.exceptionNames.invalidValue, `追加的属性中不应当包含 getter 字段`);
        this.dataValues[key] = env;
    }
    /** 判断是否存在指定的环境变量 */
    hasKey(key) {
        // @ts-ignore
        return key in this.dataValues;
    }
    /** 判断指定键对应的环境变量是否存在用户设置的值 */
    hasValue(key) {
        return this.hasKey(key) && !!this.dataValues[key].manual;
    }
    /** 获取所有键值对 */
    entries() {
        const result = {};
        for (let key in this.dataValues) {
            result[key] = this.read(key);
        }
        return result;
    }
    /** 冻结 KV 库，冻结后无法再添加和修改内容 */
    freeze() {
        if (Object.isFrozen(this.dataValues))
            return;
        this.dataValues = new Proxy(Object.freeze(this.dataValues), {
            set() {
                throw new untils_1.RuntimeException(untils_1.exceptionNames.isFrozen, 'KV 库已经被冻结无法修改');
            },
            setPrototypeOf() {
                throw new untils_1.RuntimeException(untils_1.exceptionNames.isFrozen, 'KV 库已经被冻结无法修改');
            },
            deleteProperty() {
                throw new untils_1.RuntimeException(untils_1.exceptionNames.isFrozen, 'KV 库已经被冻结无法修改');
            },
            defineProperty() {
                throw new untils_1.RuntimeException(untils_1.exceptionNames.isFrozen, 'KV 库已经被冻结无法修改');
            }
        });
    }
    get runtime() {
        return this._runtime;
    }
    get compilation() {
        return this._compilation;
    }
    set runtime(value) {
        this._runtime = value;
    }
    set compilation(value) {
        this._compilation = value;
    }
}
exports.KeyValueDatabase = KeyValueDatabase;
/**
 * 为优化 IDE 的类型推断提供的函数，直接返回传入的值
 * @param env
 */
function buildEnv(env) {
    return env;
}
/**
 * 读取指定对象中的指定字段。
 *
 * 由于配置文件中允许同时写入 T 或 `Runtime<T>`，当在配置项中使用 `this` 时，需要先判定 `this` 是哪一个类型
 */
function readThisValue(obj, key) {
    return obj[key];
}
